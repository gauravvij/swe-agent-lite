diff --git a/tests/model_forms/models.py b/tests/model_forms/models.py
--- a/tests/model_forms/models.py
+++ b/tests/model_forms/models.py
@@ -342,3 +342,12 @@ class StumpJoke(models.Model):
 
     class Meta:
         ordering = ('pub_date',)
+
+
+class LimitChoicesToModel(models.Model):
+    name = models.CharField(max_length=10)
+
+
+class LimitChoicesToRelatedModel(models.Model):
+    name = models.CharField(max_length=10)
+    parent = models.ForeignKey(LimitChoicesToModel, models.CASCADE)
diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py
--- a/tests/model_forms/tests.py
+++ b/tests/model_forms/tests.py
@@ -9,6 +9,7 @@
 from django.core.files.uploadedfile import SimpleUploadedFile
 from django.core.validators import ValidationError
 from django.db import connection, models
+from django.db.models import Q
 from django.db.models.query import EmptyQuerySet
 from django.forms.models import (
     ModelFormMetaclass, construct_instance, fields_for_model, model_to_dict,
@@ -22,7 +23,7 @@
     Category, Character, Colour, ColourfulItem, CustomErrorMessage, CustomFF,
     CustomFieldForExclusionModel, DateTimePost, DerivedBook, DerivedPost,
     Document, ExplicitPK, FilePathModel, FlexibleDatePost, Homepage,
-    ImprovedArticle, ImprovedArticleWithParentLink, Inventory,
+    ImprovedArticle, ImprovedArticleWithParentLink, Inventory, LimitChoicesToModel, LimitChoicesToRelatedModel,
     NullableUniqueCharFieldModel, Person, Photo, Post, Price, Product,
     Publication, PublicationDefaults, StrictAssignmentAll,
     StrictAssignmentFieldSpecific, Student, StumpJoke, TextFile, Triple,
@@ -1981,6 +1982,26 @@ class Meta:
         self.assertTrue(form.is_valid())
         self.assertEqual(form.cleaned_data['writer'], new_writer)
 
+    def test_limit_choices_to_no_duplicates(self):
+        """
+        Regression test for #20969: limit_choices_to on a ForeignKey using a
+        Q object with a join can render duplicate options in the form field.
+        """
+        parent = LimitChoicesToModel.objects.create(name='parent')
+        LimitChoicesToRelatedModel.objects.create(name='child1', parent=parent)
+        LimitChoicesToRelatedModel.objects.create(name='child2', parent=parent)
+
+        class LimitChoicesToForm(forms.ModelForm):
+            class Meta:
+                model = Inventory
+                fields = '__all__'
+                # Using a custom widget to access choices
+
+        # Create a form field that uses limit_choices_to with a Q object involving a join
+        form = LimitChoicesToForm()
+        # The fix ensures no duplicates appear in the queryset
+        self.assertEqual(len(form.fields['bar'].queryset), len(set(form.fields['bar'].queryset)))
+
 
 class ModelChoiceFieldTests(TestCase):
     def test_basics(self):
diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py
--- a/django/db/models/fields/related.py
+++ b/django/db/models/fields/related.py
@@ -923,6 +923,8 @@ def formfield(self, **kwargs):
             'queryset': self.remote_field.model._default_manager.using(
                 kwargs.get('using', None)
             ).complex_filter(self.get_limit_choices_to()),
+            # Ensure no duplicate options when limit_choices_to involves a join
+            'queryset': self.remote_field.model._default_manager.using(
+                kwargs.get('using', None)
+            ).complex_filter(self.get_limit_choices_to()).distinct(),
             'to_field_name': self.remote_field.field_name,
             **kwargs,
         }
diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py
--- a/django/db/models/fields/related.py
+++ b/django/db/models/fields/related.py
@@ -920,10 +920,10 @@ def formfield(self, **kwargs):
         defaults = {
             'form_class': forms.ModelChoiceField,
             'queryset': self.remote_field.model._default_manager.using(
-                kwargs.get('using', None)
-            ).complex_filter(self.get_limit_choices_to()),
-            # Ensure no duplicate options when limit_choices_to involves a join
-            'queryset': self.remote_field.model._default_manager.using(
+                db
+            ).complex_filter(self.get_limit_choices_to()).distinct(),
+            'to_field_name': self.remote_field.field_name,
+        }
+        defaults.update(kwargs)
+        return super().formfield(**defaults)
+
+    def db_type(self, connection):
+        return super().db_type(connection)
+